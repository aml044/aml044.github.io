class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transformOrigin="center";this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){if(obj.visible!==false){obj?.render(pass);}}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class FilteredRenderer extends Renderer{constructor(canvas){super(canvas);this._filters=[];}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat="rgba8unorm";this._context.configure({device:this._device,format:this._canvasFormat,});this._shaderModule=this._device.createShaderModule({label:"Image Filter Renderer Shader",code:`
      @vertex
      fn vertexMain(@builtin(vertex_index) vIdx: u32) -> @builtin(position) vec4f {
        var pos = array<vec2f, 6>(
          vec2f(-1, -1), vec2f(1, -1), vec2f(-1, 1),
          vec2f(-1, 1), vec2f(1, -1), vec2f(1, 1)
        );
        return vec4f(pos[vIdx], 0, 1);
      }
      
      @group(0) @binding(0) var inTexture: texture_2d<f32>;
      @group(0) @binding(1) var inSampler: sampler;
      
      @fragment
      fn fragmentMain(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
        let uv = fragCoord.xy / vec2f(textureDimensions(inTexture, 0));
        return textureSample(inTexture, inSampler, uv);
      }
      `});this._pipeline=this._device.createRenderPipeline({label:"Image Filter Renderer Pipeline",layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._sampler=this._device.createSampler({label:"Image Filter Renderer Sampler",magFilter:"linear",minFilter:"linear"});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;let imgSize={width:width,height:height};this._textures=[];this._textures.push(this._device.createTexture({size:imgSize,format:this._canvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,}),this._device.createTexture({size:imgSize,format:this._canvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,}),);for(const obj of this._filters){obj._imgWidth=this._textures[0].width;obj._imgHeight=this._textures[0].height;obj.updateGeometry();}
super.resizeCanvas();}
async appendFilterObject(obj){await obj.init();obj._imgWidth=this._textures[0].width;obj._imgHeight=this._textures[0].height;obj.updateGeometry();this._filters.push(obj);}
render(){super.renderToSelectedView(this._textures[0].createView());for(let i=0;i<this._filters.length;++i){let encoder=this._device.createCommandEncoder();const computePass=encoder.beginComputePass();this._filters[i].createBindGroup(this._textures[i%2],this._textures[(i+1)%2]);this._filters[i].compute(computePass);computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:this._context.getCurrentTexture().createView(),clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});const bindGroup=this._device.createBindGroup({label:"Image Filter Renderer Bind Group",layout:this._pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this._textures[this._filters.length%2].createView()},{binding:1,resource:this._sampler}],});pass.setPipeline(this._pipeline);pass.setBindGroup(0,bindGroup);pass.draw(6);pass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;this._visible=true;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class Standard2DFullScreenObject extends SceneObject{constructor(device,canvasFormat,img){super(device,canvasFormat);this._img=new Image();this._img.src=img;}
async createGeometry(){await this._img.decode();this._bitmap=await createImageBitmap(this._img);this._texture=this._device.createTexture({label:"Texture "+this.getName(),size:[this._bitmap.width,this._bitmap.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,});this._device.queue.copyExternalImageToTexture({source:this._bitmap},{texture:this._texture},[this._bitmap.width,this._bitmap.height]);this._sampler=this._device.createSampler({magFilter:"linear",minFilter:"linear"});}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_fullscreen.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._bindGroup=this._device.createBindGroup({layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this._texture.createView(),},{binding:1,resource:this._sampler,}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setBindGroup(0,this._bindGroup);pass.draw(6,1,0,0);}
async createComputePipeline(){}
compute(pass){}}
class Standard2DPGAPosedVertexColorObject extends SceneObject{constructor(device,canvasFormat,vertices,pose){super(device,canvasFormat);this._vertices=vertices;this._pose=pose;}
async createGeometry(){console.log('Here');console.log(this._vertices.byteLength);this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,},{shaderLocation:1,format:"float32x4",offset:2*Float32Array.BYTES_PER_ELEMENT,}],};this._poseBuffer=this._device.createBuffer({label:"Pose "+this.getName(),size:this._pose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
updateGeometry(){this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2dpgacolored.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._bindGroup=this._device.createBindGroup({label:"Render Bind Group "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._poseBuffer},}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroup);pass.draw(this._vertices.length/6);}
async createComputePipeline(){}
compute(pass){}}
class Standard2DVertexColorObject extends SceneObject{constructor(device,canvasFormat,vertices){super(device,canvasFormat);this._vertices=vertices;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,},{shaderLocation:1,format:"float32x4",offset:2*Float32Array.BYTES_PER_ELEMENT,}],};}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2dcolored.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.draw(this._vertices.length/6);}
async createComputePipeline(){}
compute(pass){}}
class LineStrip2DVertexObject extends SceneObject{constructor(device,canvasFormat,vertices){super(device,canvasFormat);this._vertices=vertices;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,}],};}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2d.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},primitive:{topology:'line-strip'}});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.draw(this._vertices.length/2);}
async createComputePipeline(){}
compute(pass){}}
class DemoTreeObject extends Standard2DPGAPosedVertexColorObject{constructor(device,canvasFormat,pose){let _vertices=new Float32Array([0,0.075,255.0/255,150.0/255,150.0/255,1,-0.1,-0.5,255.0/255,150.0/255,150.0/255,1,0.1,-0.5,255.0/255,150.0/255,150.0/255,1,-0.052,-0.15,120.0/255,0/255,0/255,1,-0.052,-0.45,120/255,0.0/255,0.0/255,1,0.052,-0.45,120/255,0.0/255,0.0/255,1,-0.052,-0.15,120/255,0.0/255,0.0/255,1,0.052,-0.45,120/255,0.0/255,0.0/255,1,0.052,-0.15,120/255,0.0/255,0.0/255,1,0,0.075,150.0/255,150.0/255,150.0/255,1,-0.15,-0.4,150.0/255,150.0/255,150.0/255,1,0.15,-0.4,150.0/255,150.0/255,150.0/255,1,]);super(device,canvasFormat,_vertices,pose);this._interval=100;this._t=0;this._step=1;this._pose0=[-1,0,0.5,0.5,0.5,0.5];this._pose1=[0,1,-0.5,0.5,0.5,0.5];}
updateGeometry(){this._pose[0]=this._pose0[0]*(1-this._t/this._interval)+this._pose1[0]*this._t/this._interval;this._pose[1]=this._pose0[1]*(1-this._t/this._interval)+this._pose1[1]*this._t/this._interval;this._pose[2]=this._pose0[2]*(1-this._t/this._interval)+this._pose1[2]*this._t/this._interval;this._pose[3]=this._pose0[3]*(1-this._t/this._interval)+this._pose1[3]*this._t/this._interval;this._t+=this._step;if(this._t>=100){this._step=-1;}
else if(this._t<=0){this._step=1;}
super.updateGeometry();}}
class PGA2D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1],a[0]*b[1]+a[1]*b[0],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3]];}
static applyMotor(p,m){return PGA2D.geometricProduct(m,PGA2D.geometricProduct(p,PGA2D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]+m[3]*m[3]);}
static createTranslator(dx,dy){return[1,0,dy/2,-dx/2]}
static createRotor(angle,cx=0,cy=0){return[Math.cos(angle/2),-Math.sin(angle/2),-cx*Math.sin(angle/2),-cy*Math.sin(angle/2)];}
static normalizeMotor(m){let mnorm=PGA2D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0];}
return[m[0]/mnorm,m[1]/mnorm,m[2]/mnorm,m[3]/mnorm];}
inverseMotor(m){let a=m[0],b=m[1],c=m[2],d=m[3];return[a,-b,-c,-d];}
static applyMotorToPoint(p,m){let new_p=PGA2D.applyMotor([0,1,p[0],p[1]],m);return[new_p[2]/new_p[1],new_p[3]/new_p[1]];};}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const renderer=new FilteredRenderer(canvasTag);await renderer.init();const bgButton=document.createElement("button");bgButton.innerText="Switch Background (b)";bgButton.style.position="absolute";bgButton.style.top="10px";bgButton.style.left="10px";bgButton.style.zIndex="1000";document.body.appendChild(bgButton);const bg1=new Standard2DFullScreenObject(renderer._device,renderer._canvasFormat,"/assets/cosmos.jpg");const bg2=new Standard2DFullScreenObject(renderer._device,renderer._canvasFormat,"/assets/deathstar.jpeg");const bg3=new Standard2DFullScreenObject(renderer._device,renderer._canvasFormat,"/assets/black_hole.jpeg");const bg4=new Standard2DFullScreenObject(renderer._device,renderer._canvasFormat,"/assets/Galaxy_blue.jpg");const bg5=new Standard2DFullScreenObject(renderer._device,renderer._canvasFormat,"/assets/mario_cosmo.jpeg");const bg6=new Standard2DFullScreenObject(renderer._device,renderer._canvasFormat,"/assets/fantasy.jpg");const bg7=new Standard2DFullScreenObject(renderer._device,renderer._canvasFormat,"/assets/explosion.jpeg");await renderer.appendSceneObject(bg1);await renderer.appendSceneObject(bg2);await renderer.appendSceneObject(bg3);await renderer.appendSceneObject(bg4);await renderer.appendSceneObject(bg5);await renderer.appendSceneObject(bg6);await renderer.appendSceneObject(bg7);const backgrounds=[bg1,bg2,bg3,bg4,bg5,bg6,bg7];let currentBackgroundIndex=0;bg1.visible=true;bg2.visible=false;bg3.visible=false;bg4.visible=false;bg5.visible=false;bg6.visible=false;bg7.visible=false;const keySegments=30;const keyRadius=.3;const keyCenterX=0;const keyCenterY=0;const verticesKey=[];for(let i=0;i<keySegments;i++){const angle1=(i/keySegments)*2*Math.PI;const angle2=((i+1)/keySegments)*2*Math.PI;verticesKey.push(keyCenterX,keyCenterY,1,1,0,0);verticesKey.push(keyCenterX+keyRadius*Math.cos(angle1),keyCenterY+keyRadius*Math.sin(angle1),1,1,0,0);verticesKey.push(keyCenterX+keyRadius*Math.cos(angle2),keyCenterY+keyRadius*Math.sin(angle2),1,1,0,0);}
var pose=[1,0,0,0,1,1];pose=new Float32Array(pose);const sunObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(verticesKey),pose);await renderer.appendSceneObject(sunObj);let explosionMode=false;const uiText=document.createElement("div");uiText.style.position="absolute";uiText.style.top="50px";uiText.style.left="10px";uiText.style.zIndex="1000";uiText.style.fontSize="20px";uiText.style.fontWeight="bold";uiText.style.color="white";uiText.innerText="";document.body.appendChild(uiText);uiText.innerText="ðŸ’¥ Press 'X' to destroy the universe!";window.addEventListener("keydown",(e)=>{if(e.key==="b"){switchBackground();}});window.addEventListener("keydown",(e)=>{if(e.key==="x"){enterExplosionMode();}else if(e.key==="r"){if(explosionMode){exitExplosionMode();}}});function enterExplosionMode(){explosionMode=true;backgrounds.forEach(bg=>bg.visible=false);bg7.visible=true;const hiddenObjs=[sunObj,mercuryObj,venusObj,earthObj,moonObj,marsObj,jupiterObj,saturnObj,uranusObj,neptuneObj,rocketObj];hiddenObjs.forEach(obj=>obj.visible=false);uiText.innerText="ðŸ’¥ Press 'R' to rebuild the solar system.";}
function exitExplosionMode(){explosionMode=false;backgrounds.forEach(bg=>bg.visible=false);backgrounds[currentBackgroundIndex].visible=true;const showObjs=[sunObj,mercuryObj,venusObj,earthObj,moonObj,marsObj,jupiterObj,saturnObj,uranusObj,neptuneObj,rocketObj];showObjs.forEach(obj=>obj.visible=true);uiText.innerText="ðŸ’¥ Press 'X' to destroy the universe!";}
function switchBackground(){backgrounds[currentBackgroundIndex].visible=false;currentBackgroundIndex=(currentBackgroundIndex+1)%backgrounds.length;if(currentBackgroundIndex==6){currentBackgroundIndex=0;}
backgrounds[currentBackgroundIndex].visible=true;console.log("Switched background to index",currentBackgroundIndex);}
const mercSegments=30;const mercRadius=.04;const mercCenterX=.35;const mercCenterY=-.2;const mercVertices=[];for(let i=0;i<mercSegments;i++){const angle1=(i/mercSegments)*2*Math.PI;const angle2=((i+1)/mercSegments)*2*Math.PI;mercVertices.push(mercCenterX,mercCenterY,150/225.0,150/255.0,150/255.0,0);mercVertices.push(mercCenterX+mercRadius*Math.cos(angle1),mercCenterY+mercRadius*Math.sin(angle1),150/225.0,150/255.0,150/255.0,0);mercVertices.push(mercCenterX+mercRadius*Math.cos(angle2),mercCenterY+mercRadius*Math.sin(angle2),150/225.0,150/255.0,150/255.0,0);}
var mercuryPose=[1,1,0,0,1,1];mercuryPose=new Float32Array(mercuryPose);const mercuryObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(mercVertices),mercuryPose);await renderer.appendSceneObject(mercuryObj);const venusSegments=30;const venusRadius=.05;const venusCenterX=.5;const venusCenterY=-.2;const venusVertices=[];for(let i=0;i<venusSegments;i++){const angle1=(i/venusSegments)*2*Math.PI;const angle2=((i+1)/venusSegments)*2*Math.PI;venusVertices.push(venusCenterX,venusCenterY,255/225.0,0/255.0,0/255.0,0);venusVertices.push(venusCenterX+venusRadius*Math.cos(angle1),venusCenterY+venusRadius*Math.sin(angle1),255/225.0,0/255.0,0/255.0,0);venusVertices.push(venusCenterX+venusRadius*Math.cos(angle2),venusCenterY+venusRadius*Math.sin(angle2),255/225.0,0/255.0,0/255.0,0);}
var venusPose=[1,1,0,0,1,1];venusPose=new Float32Array(venusPose);const venusObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(venusVertices),venusPose);await renderer.appendSceneObject(venusObj);const earthSegments=30;const earthRadius=.05;const earthCenterX=.62;const earthCenterY=-.27;const earthVertices=[];for(let i=0;i<earthSegments;i++){const angle1=(i/earthSegments)*2*Math.PI;const angle2=((i+1)/earthSegments)*2*Math.PI;earthVertices.push(earthCenterX,earthCenterY,0/225.0,0/255.0,255/255.0,0);earthVertices.push(earthCenterX+earthRadius*Math.cos(angle1),earthCenterY+earthRadius*Math.sin(angle1),0/225.0,0/255.0,255/255.0,0);earthVertices.push(earthCenterX+earthRadius*Math.cos(angle2),earthCenterY+earthRadius*Math.sin(angle2),0/225.0,0/255.0,255/255.0,0);}
var earthPose=[1,1,0,0,1,1];earthPose=new Float32Array(earthPose);const earthObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(earthVertices),earthPose);await renderer.appendSceneObject(earthObj);const moonSegments=30;const moonRadius=0.005;const moonCenterX=.70;const moonCenterY=-.20;const moonVertices=[];for(let i=0;i<moonSegments;i++){const angle1=(i/moonSegments)*2*Math.PI;const angle2=((i+1)/moonSegments)*2*Math.PI;moonVertices.push(moonCenterX,moonCenterY,150/225.0,150/255.0,150/255.0,0);moonVertices.push(moonCenterX+moonRadius*Math.cos(angle1),moonCenterY+moonRadius*Math.sin(angle1),150/225.0,150/255.0,150/255.0,0);moonVertices.push(moonCenterX+moonRadius*Math.cos(angle2),moonCenterY+moonRadius*Math.sin(angle2),150/225.0,150/255.0,150/255.0,0);}
var moonPose=[1,1,.62,-.67,1,1];moonPose=new Float32Array(moonPose);const moonObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(moonVertices),moonPose);await renderer.appendSceneObject(moonObj);const marsSegments=30;const marsRadius=.05;const marsCenterX=.62;const marsCenterY=-.27;const marsVertices=[];for(let i=0;i<marsSegments;i++){const angle1=(i/marsSegments)*2*Math.PI;const angle2=((i+1)/marsSegments)*2*Math.PI;marsVertices.push(marsCenterX,marsCenterY,200/225.0,70/255.0,10/255.0,0);marsVertices.push(marsCenterX+marsRadius*Math.cos(angle1),marsCenterY+marsRadius*Math.sin(angle1),200/225.0,70/255.0,10/255.0,0);marsVertices.push(marsCenterX+marsRadius*Math.cos(angle2),marsCenterY+marsRadius*Math.sin(angle2),200/225.0,70/255.0,10/255.0,0);}
var marsPose=[1,0,0,0,1,1];marsPose=new Float32Array(marsPose);const marsObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(marsVertices),marsPose);await renderer.appendSceneObject(marsObj);const jupiterSegments=30;const jupiterRadius=.08;const jupiterCenterX=.7;const jupiterCenterY=-.3;const jupiterVertices=[];for(let i=0;i<jupiterSegments;i++){const angle1=(i/jupiterSegments)*2*Math.PI;const angle2=((i+1)/jupiterSegments)*2*Math.PI;jupiterVertices.push(jupiterCenterX,jupiterCenterY,225/225.0,215/255.0,215/255.0,0);jupiterVertices.push(jupiterCenterX+jupiterRadius*Math.cos(angle1),jupiterCenterY+jupiterRadius*Math.sin(angle1),225/225.0,215/255.0,215/255.0,0);jupiterVertices.push(jupiterCenterX+jupiterRadius*Math.cos(angle2),jupiterCenterY+jupiterRadius*Math.sin(angle2),225/225.0,215/255.0,215/255.0,0);}
var jupiterPose=[1,.32,0,0,1,1];jupiterPose=new Float32Array(jupiterPose);const jupiterObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(jupiterVertices),jupiterPose);await renderer.appendSceneObject(jupiterObj);const saturnSegments=30;const saturnRadius=.08;const saturnCenterX=.79;const saturnCenterY=-.38;const saturnVertices=[];for(let i=0;i<saturnSegments;i++){const angle1=(i/saturnSegments)*2*Math.PI;const angle2=((i+1)/saturnSegments)*2*Math.PI;saturnVertices.push(saturnCenterX,saturnCenterY,215/225.0,119/255.0,35/255.0,0);saturnVertices.push(saturnCenterX+saturnRadius*Math.cos(angle1),saturnCenterY+saturnRadius*Math.sin(angle1),215/225.0,119/255.0,35/255.0,0);saturnVertices.push(saturnCenterX+saturnRadius*Math.cos(angle2),saturnCenterY+saturnRadius*Math.sin(angle2),215/225.0,119/255.0,35/255.0,0);}
var saturnPose=[0,0,0,0,1,1];saturnPose=new Float32Array(saturnPose);const saturnObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(saturnVertices),saturnPose);await renderer.appendSceneObject(saturnObj);const uranusSegments=30;const uranusRadius=.05;const uranusCenterX=.8;const uranusCenterY=-.4;const uranusVertices=[];for(let i=0;i<uranusSegments;i++){const angle1=(i/uranusSegments)*2*Math.PI;const angle2=((i+1)/uranusSegments)*2*Math.PI;uranusVertices.push(uranusCenterX,uranusCenterY,0/225.0,255/255.0,255/255.0,0);uranusVertices.push(uranusCenterX+uranusRadius*Math.cos(angle1),uranusCenterY+uranusRadius*Math.sin(angle1),0/225.0,255/255.0,215/255.0,0);uranusVertices.push(uranusCenterX+uranusRadius*Math.cos(angle2),uranusCenterY+uranusRadius*Math.sin(angle2),0/225.0,255/255.0,255/255.0,0);}
var uranusPose=[1,.56,0,0,1,1];uranusPose=new Float32Array(uranusPose);const uranusObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(uranusVertices),uranusPose);await renderer.appendSceneObject(uranusObj);const neptuneSegments=30;const neptuneRadius=.06;const neptuneCenterX=1;const neptuneCenterY=-.25;const neptuneVertices=[];for(let i=0;i<neptuneSegments;i++){const angle1=(i/neptuneSegments)*2*Math.PI;const angle2=((i+1)/neptuneSegments)*2*Math.PI;neptuneVertices.push(neptuneCenterX,neptuneCenterY,0/225.0,0/255.0,159/255.0,0);neptuneVertices.push(neptuneCenterX+neptuneRadius*Math.cos(angle1),neptuneCenterY+neptuneRadius*Math.sin(angle1),0/225.0,0/255.0,159/255.0,0);neptuneVertices.push(neptuneCenterX+neptuneRadius*Math.cos(angle2),neptuneCenterY+neptuneRadius*Math.sin(angle2),0/225.0,0/255.0,159/255.0,0);}
var neptunePose=[1,.77,0,0,1,1];neptunePose=new Float32Array(neptunePose);const neptuneObj=new Standard2DPGAPosedVertexColorObject(renderer._device,renderer._canvasFormat,new Float32Array(neptuneVertices),neptunePose);await renderer.appendSceneObject(neptuneObj);let demoTreePose=new Float32Array([1,0,0,0,0.5,0.5]);const rocketObj=new DemoTreeObject(renderer._device,renderer._canvasFormat,demoTreePose)
await renderer.appendSceneObject(rocketObj);let angle=Math.PI/100;let center=[0,0];let dr=PGA2D.normalizeMotor([Math.cos(angle/2),-Math.sin(angle/2),-center[0]*Math.sin(angle/2),-center[1]*Math.sin(angle/2)]);setInterval(()=>{renderer.render();let mercuryMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[mercuryPose[0],mercuryPose[1],mercuryPose[2],mercuryPose[3]]));mercuryPose[0]=mercuryMotor[0];mercuryPose[1]=mercuryMotor[1];mercuryPose[2]=mercuryMotor[2];mercuryPose[3]=mercuryMotor[3];let venusMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[venusPose[0],venusPose[1],venusPose[2],venusPose[3]]));venusPose[0]=venusMotor[0];venusPose[1]=venusMotor[1];venusPose[2]=venusMotor[2];venusPose[3]=venusMotor[3];let demoTreeMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[demoTreePose[0],demoTreePose[1],demoTreePose[2],demoTreePose[3]]));demoTreePose[0]=demoTreeMotor[0];demoTreePose[1]=demoTreeMotor[1];demoTreePose[2]=demoTreeMotor[2];demoTreePose[3]=demoTreeMotor[3];let earthTreeMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[earthPose[0],earthPose[1],earthPose[2],earthPose[3]]));earthPose[0]=earthTreeMotor[0];earthPose[1]=earthTreeMotor[1];earthPose[2]=earthTreeMotor[2];earthPose[3]=earthTreeMotor[3];let marsMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[marsPose[0],marsPose[1],marsPose[2],marsPose[3]]));marsPose[0]=marsMotor[0];marsPose[1]=marsMotor[1];marsPose[0]=marsMotor[0];marsPose[3]=marsMotor[3];let jupiterMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[jupiterPose[0],jupiterPose[1],jupiterPose[2],jupiterPose[3]]));jupiterPose[0]=jupiterMotor[0];jupiterPose[1]=jupiterMotor[1];jupiterPose[2]=jupiterMotor[2];jupiterPose[3]=jupiterMotor[3];let saturnMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[saturnPose[0],saturnPose[1],saturnPose[2],saturnPose[3]]));saturnPose[0]=saturnMotor[0];saturnPose[1]=saturnMotor[1];saturnPose[2]=saturnMotor[2];saturnPose[3]=saturnMotor[3];let uranusMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[uranusPose[0],uranusPose[1],uranusPose[2],uranusPose[3]]));uranusPose[0]=uranusMotor[0];uranusPose[1]=uranusMotor[1];uranusPose[2]=uranusMotor[2];uranusPose[3]=uranusMotor[3];let neptuneMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[neptunePose[0],neptunePose[1],neptunePose[2],uranusPose[3]]));neptunePose[0]=neptuneMotor[0];neptunePose[1]=neptuneMotor[1];neptunePose[2]=neptuneMotor[2];neptunePose[3]=neptuneMotor[3];let moonMotor=PGA2D.normalizeMotor(PGA2D.geometricProduct(dr,[moonPose[0],moonPose[1],moonPose[2],moonPose[3]]));moonPose[0]=moonMotor[0];moonPose[1]=moonMotor[1];moonPose[2]=moonMotor[2];moonPose[3]=moonMotor[3];},100);return renderer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});