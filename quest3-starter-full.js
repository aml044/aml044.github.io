class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transformOrigin="center";this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class PGA2D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1],a[0]*b[1]+a[1]*b[0],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3]];}
static applyMotor(p,m){return PGA2D.geometricProduct(m,PGA2D.geometricProduct(p,PGA2D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]+m[3]*m[3]);}
static createTranslator(dx,dy){return[1,0,dy/2,-dx/2]}
static createRotor(angle,cx=0,cy=0){return[Math.cos(angle/2),-Math.sin(angle/2),-cx*Math.sin(angle/2),-cy*Math.sin(angle/2)];}
static normaliozeMotor(m){let mnorm=PGA2D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0];}
return[m[0]/mnorm,m[1]/mnorm,m[2]/mnorm,m[3]/mnorm];}
static applyMotorToPoint(p,m){let new_p=PGA2D.applyMotor([0,1,p[0],p[1]],m);return[new_p[2]/new_p[1],new_p[3]/new_p[1]];};}
class Camera{constructor(){this._pose=new Float32Array([1,0,0,0,1,1]);}
resetPose(){this._pose[0]=1;this._pose[1]=0;this._pose[2]=0;this._pose[3]=0;this._pose[4]=1;this._pose[5]=1;}
updatePose(newpose){this._pose[0]=newpose[0];this._pose[1]=newpose[1];this._pose[2]=newpose[2];this._pose[3]=newpose[3];}
moveLeft(d){let dt=PGA2D.createTranslator(-d,0);let newpose=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveRight(d){let dt=PGA2D.createTranslator(d,0);let newpose=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveUp(d){let dt=PGA2D.createTranslator(0,d);let newpose=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveDown(d){let dt=PGA2D.createTranslator(0,-d);let newpose=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
zoomIn(){this._pose[4]*=1.1;this._pose[5]*=1.1;}
zoomOut(){this._pose[4]/=1.1;this._pose[5]/=1.1;}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class CameraLineStrip2DAliveDeadObject extends SceneObject{constructor(device,canvasFormat,cameraPose,vertices){super(device,canvasFormat);this._cameraPose=cameraPose;if(typeof this._vertices===Float32Array)this._vertices=vertices;else this._vertices=new Float32Array(vertices);}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,}],};this._cameraPoseBuffer=this._device.createBuffer({label:"Camera Pose "+this.getName(),size:this._cameraPose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);this._cellStatus=new Uint32Array(10*10);this._cellStateBuffers=[this._device.createBuffer({label:"Grid status Buffer 1 "+this.getName(),size:this._cellStatus.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,}),this._device.createBuffer({label:"Grid status Buffer 2 "+this.getName(),size:this._cellStatus.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,})];this._device.queue.writeBuffer(this._cellStateBuffers[0],0,this._cellStatus);this._step=0;}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_camera2dalivedead.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});this._bindGroupLayout=this._device.createBindGroupLayout({label:"Grid Bind Group Layout "+this.getName(),entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});this._pipelineLayout=this._device.createPipelineLayout({label:"Grid Pipeline Layout",bindGroupLayouts:[this._bindGroupLayout],});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:this._pipelineLayout,vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},primitive:{topology:'line-strip'}});this._bindGroups=[this._device.createBindGroup({label:"Renderer Bind Group 1 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[0]}},{binding:2,resource:{buffer:this._cellStateBuffers[1]}}],}),this._device.createBindGroup({label:"Renderer Bind Group 2 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[1]}},{binding:2,resource:{buffer:this._cellStateBuffers[0]}}],})];}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.draw(this._vertices.length/2,10*10);}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Grid update pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeMain",}});}
compute(pass){pass.setPipeline(this._computePipeline);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.dispatchWorkgroups(Math.ceil(10/4),Math.ceil(10/4));++this._step;}}
class CameraLineStrip2DGridObject extends SceneObject{constructor(device,canvasFormat,cameraPose,vertices){super(device,canvasFormat);this._cameraPose=cameraPose;if(typeof this._vertices===Float32Array)this._vertices=vertices;else this._vertices=new Float32Array(vertices);}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,}],};this._cameraPoseBuffer=this._device.createBuffer({label:"Camera Pose "+this.getName(),size:this._cameraPose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);this._cellStatus=new Uint32Array(256*256);const cellByteSize=256*256*Uint32Array.BYTES_PER_ELEMENT;this._cellStateBuffers=[this._device.createBuffer({label:"Grid status Buffer 1 "+this.getName(),size:cellByteSize,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,}),this._device.createBuffer({label:"Grid status Buffer 2 "+this.getName(),size:cellByteSize,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,})];this._device.queue.writeBuffer(this._cellStateBuffers[0],0,this._cellStatus);this._step=0;}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_camera2dgrid.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});this._bindGroupLayout=this._device.createBindGroupLayout({label:"Grid Bind Group Layout "+this.getName(),entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});this._pipelineLayout=this._device.createPipelineLayout({label:"Grid Pipeline Layout",bindGroupLayouts:[this._bindGroupLayout],});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:this._pipelineLayout,vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},primitive:{topology:'line-strip'}});this._bindGroups=[this._device.createBindGroup({label:"Renderer Bind Group 1 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[0]}},{binding:2,resource:{buffer:this._cellStateBuffers[1]}}],}),this._device.createBindGroup({label:"Renderer Bind Group 2 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[1]}},{binding:2,resource:{buffer:this._cellStateBuffers[0]}}],})];}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.draw(this._vertices.length/2,256*256);}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Grid update pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeMain",}});}
compute(pass){pass.setPipeline(this._computePipeline);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.dispatchWorkgroups(Math.ceil(256/4),Math.ceil(256/4));++this._step;}}
class StandardTextObject{constructor(inputText,spacing=5,textFont='18px Arial'){this._textFont=textFont;this._lineSpacing=spacing;this._textCanvas=document.createElement('canvas');this._textContext=this._textCanvas.getContext('2d');this.updateTextRegion(inputText);this.updateText(inputText);this._textCanvas.style.position='absolute';this._textCanvas.style.top='10px';this._textCanvas.style.left='10px';this._textCanvas.style.border='1px solid red';document.body.appendChild(this._textCanvas);}
toggleVisibility(){this._textCanvas.hidden=!this._textCanvas.hidden;}
updateTextRegion(newText){this._textContext.font=this._textFont;this._lines=newText.split('\n');this._width=Math.max(...this._lines.map(line=>this._textContext.measureText(line).width));const match=this._textFont.match(/(\d+)px/);if(match){this._fontSize=parseInt(match[1],10);}
else{this._fontSize=18;this._textFont="18px Arial";}
this._height=this._lines.length*(this._fontSize+this._lineSpacing);this._paddingx=5;this._paddingtop=3;this._canvasWidth=Math.ceil(this._width+this._paddingx*2);this._canvasHeight=Math.ceil(this._height+this._paddingtop);this._textCanvas.width=this._canvasWidth;this._textCanvas.height=this._canvasHeight;this._textContext.font=this._textFont;this._textContext.textBaseline='top';}
updateText(newText){this._lines=newText.split('\n');this._textContext.fillStyle='rgba(1, 1, 1, 0.5)';this._textContext.clearRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillStyle='white';this._lines.forEach((line,idx)=>{const x=this._paddingx;const y=this._paddingtop+idx*(this._fontSize+this._lineSpacing);this._textContext.fillText(line,x,y);});}}
class Standard2DPGACameraSceneObject extends SceneObject{constructor(device,canvasFormat,cameraPose,vertices,pose){super(device,canvasFormat);this._vertices=vertices;this._pose=pose;this._cameraPose=cameraPose;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,},{shaderLocation:1,format:"float32x4",offset:2*Float32Array.BYTES_PER_ELEMENT,}],};this._poseBuffer=this._device.createBuffer({label:"Pose "+this.getName(),size:this._pose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);this._cameraPoseBuffer=this._device.createBuffer({label:"Camera Pose "+this.getName(),size:this._cameraPose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
updateGeometry(){this._device.queue.writeBuffer(this._poseBuffer,0,this._pose);}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_standard2dpgacamera.wgsl");this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]}});this._bindGroup=this._device.createBindGroup({label:"Render Bind Group "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._poseBuffer},},{binding:1,resource:{buffer:this._cameraPoseBuffer}}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroup);pass.draw(this._vertices.length/6);}
async createComputePipeline(){}
compute(pass){}}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const renderer=new Renderer(canvasTag);await renderer.init();var vertices=new Float32Array([-0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5]);const camera=new Camera();const grid=new CameraLineStrip2DGridObject(renderer._device,renderer._canvasFormat,camera._pose,vertices);await renderer.appendSceneObject(grid);const defaultPose=new Float32Array([1,0,0,0,0.025,0.025]);var pose=new Float32Array(defaultPose);var quadVertices=new Float32Array([-1,-1,1,0,0,1,1,-1,0,1,0,1,-1,1,0,0,1,1,1,1,1,0,1,1,-1,1,0,0,1,1,1,-1,0,1,0,1]);const quad=new Standard2DPGACameraSceneObject(renderer._device,renderer._canvasFormat,camera._pose,quadVertices,pose);await renderer.appendSceneObject(quad);let fps='??';var fpsText=new StandardTextObject('fps: '+fps+'\nPause: P/p'+'\nMove: Arrow Keys/WASD'+'\nZoom In: Q/q'+'\nZoom Out: E/e');var frameCnt=0;var tgtFPS=60;var minFPS=10;var maxFPS=120;console.log(tgtFPS);var secPerFrame=1./tgtFPS;var frameInterval=secPerFrame*1000;var lastCalled=Date.now();let isPaused=false;function resetSimulation(){console.log("simulation reset");camera._pose=new Float32Array([1,0,0,0,1,1]);grid.updateCameraPose();quad.updateCameraPose();pose.set(defaultPose);quad.updateGeometry();frameCnt=0;isPaused=false;renderer.render();}
var movespeed=0.05;window.addEventListener("keydown",(e)=>{switch(e.key){case'ArrowUp':case'w':case'W':camera.moveDown(movespeed);grid.updateCameraPose();quad.updateCameraPose();break;case'ArrowDown':case's':case'S':camera.moveUp(movespeed);grid.updateCameraPose();quad.updateCameraPose();break;case'ArrowLeft':case'a':case'A':camera.moveRight(movespeed);grid.updateCameraPose();quad.updateCameraPose();break;case'ArrowRight':case'd':case'D':camera.moveLeft(movespeed);grid.updateCameraPose();quad.updateCameraPose();break;case'q':case'Q':camera.zoomIn();grid.updateCameraPose();quad.updateCameraPose();break;case'e':case'E':camera.zoomOut();grid.updateCameraPose();quad.updateCameraPose();break;case'f':case'F':fpsText.toggleVisibility();break;case'p':case'P':isPaused=!isPaused;console.log(isPaused?"Simulation Paused":"Simulation Resumed");break;case'r':case'R':resetSimulation();console.log("OUT");break;}});const gridSize=256;let cellStates=Array(gridSize*gridSize).fill(false);let isClicked=false;let isDragging=false;let oldP=[0,0];window.addEventListener('mousedown',(e)=>{var mouseX=(e.clientX/window.innerWidth)*2-1;var mouseY=(-e.clientY/window.innerHeight)*2+1;mouseX/=camera._pose[4];mouseY/=camera._pose[5];let p=PGA2D.applyMotorToPoint([mouseX,mouseY],[camera._pose[0],camera._pose[1],camera._pose[2],camera._pose[3]]);let cellWidth=1.0/gridSize;let cellHeight=1.0/gridSize;let u=Math.floor((p[0]+0.5)/cellWidth);let v=Math.floor((p[1]+0.5)/cellHeight);if(u>=0&&u<gridSize&&v>=0&&v<gridSize){let cellIndex=v*gridSize+u;if(!neverDeadCells.has(cellIndex)){cellStates[cellIndex]=!cellStates[cellIndex];}}});function enforceCameraBoundaries(){const zoomLevel=camera._pose[4];const minZoom=1.0;const maxZoom=5.0;if(zoomLevel<minZoom){camera._pose[4]=minZoom;return false;}
if(zoomLevel>maxZoom){camera._pose[4]=maxZoom;return false;}
return true;}
window.addEventListener('mousemove',(e)=>{var mouseX=(e.clientX/window.innerWidth)*2-1;var mouseY=(-e.clientY/window.innerHeight)*2+1;mouseX/=camera._pose[4];mouseY/=camera._pose[5];let p=PGA2D.applyMotorToPoint([mouseX,mouseY],[camera._pose[0],camera._pose[1],camera._pose[2],camera._pose[3]]);let halfLength=1;let cellLength=halfLength*2;let u=Math.floor((p[0]+halfLength)/cellLength*10);let v=Math.floor((p[1]+halfLength)/cellLength*10);if(u>=0&&u<10&&v>=0&&v<10){let offsetX=-halfLength+u/10*cellLength+cellLength/10*0.5;let offsetY=-halfLength+v/10*cellLength+cellLength/10*0.5;if(-0.5/10+offsetX<=p[0]&&p[0]<=0.5/10+offsetX&&-0.5/10+offsetY<=p[1]&&p[1]<=0.5/10+offsetY){console.log(`in cell (${u}, ${v})`);}}
if(isDragging){let diff=Math.sqrt(Math.pow(p[0]-oldP[0],2)+Math.pow(p[1]-oldP[1],2));if(diff>0.001){let dt=PGA2D.createTranslator((p[0]-oldP[0])/pose[4],(p[1]-oldP[1])/pose[5]);let newmotor=PGA2D.normaliozeMotor(PGA2D.geometricProduct(dt,[pose[0],pose[1],pose[2],pose[3]]));pose[0]=newmotor[0];pose[1]=newmotor[1];pose[2]=newmotor[2];pose[3]=newmotor[3];quad.updateGeometry();oldP=p;}}});window.addEventListener('mouseup',(e)=>{isDragging=false;});let renderFrame=()=>{let elapsed=Date.now()-lastCalled;if(!isPaused&&elapsed>frameInterval){++frameCnt;lastCalled=Date.now()-(elapsed%frameInterval);renderer.render();}
requestAnimationFrame(renderFrame);};window.addEventListener("keydown",(e)=>{switch(e.key){case'q':case'Q':camera.zoomIn();if(enforceCameraBoundaries()){grid.updateCameraPose();}
break;case'e':case'E':camera.zoomOut();if(enforceCameraBoundaries()){grid.updateCameraPose();}
break;case'+':case'=':adjustSpeed(true);console.log('increase');break;case'-':adjustSpeed(false);console.log('decrease');break;}});renderFrame();setInterval(()=>{fpsText.updateText('fps: '+frameCnt+'\nPause: P/p'+'\nMove: Arrow Keys/WASD'+'\nZoom In: Q/q'+'\nZoom Out: E/e');frameCnt=0;},1000);return renderer;}
let minFPS=10;let maxFPS=120;let tgtFPS=30;let secPerFrame=1./tgtFPS;let frameInterval=secPerFrame*1000;let lastCalled=Date.now();function adjustSpeed(increase){if(increase){tgtFPS=Math.min(tgtFPS+10,maxFPS);}else{tgtFPS=Math.max(tgtFPS-10,minFPS);}
secPerFrame=1.0/tgtFPS;frameInterval=secPerFrame*1000;console.log('Speed adjusted: FPS = '+tgtFPS);}
const neverDeadCells=new Set([12,34,78]);function updateGridColors(){const newVertices=[];for(let v=0;v<gridSize;v++){for(let u=0;u<gridSize;u++){let x=u/gridSize-0.5;let y=v/gridSize-0.5;let cellIndex=v*gridSize+u;let color;if(neverDeadCells.has(cellIndex)){color=[0,0,1,1];}else if(cellStates[cellIndex]){color=[1,0,0,1];}else{color=[0.8,0.8,0.8,1];}
newVertices.push(x,y,...color,x+1.0/gridSize,y,...color,x,y+1.0/gridSize,...color,x+1.0/gridSize,y,...color,x+1.0/gridSize,y+1.0/gridSize,...color,x,y+1.0/gridSize,...color);}}
grid._vertices=new Float32Array(newVertices);grid.updateGeometry();}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});