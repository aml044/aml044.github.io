class Renderer{constructor(canvas){this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1};}
async init(){if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas(){const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this._canvas.style.transform="scaleY(-1)";this._canvas.style.transformOrigin="center";this._zBuffer=this._device.createTexture({size:[this._canvas.width,this._canvas.height,1],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}],depthStencilAttachment:{view:this._zBuffer.createView(),depthLoadOp:"clear",depthStoreOp:"store",depthClearValue:1.0}});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class StandardTextObject{constructor(inputText,spacing=5,textFont='18px Arial'){this._textFont=textFont;this._lineSpacing=spacing;this._textCanvas=document.createElement('canvas');this._textContext=this._textCanvas.getContext('2d');this.updateTextRegion(inputText);this.updateText(inputText);this._textCanvas.style.position='absolute';this._textCanvas.style.top='10px';this._textCanvas.style.left='10px';this._textCanvas.style.border='1px solid red';document.body.appendChild(this._textCanvas);}
toggleVisibility(){this._textCanvas.hidden=!this._textCanvas.hidden;}
updateTextRegion(newText){this._textContext.font=this._textFont;this._lines=newText.split('\n');this._width=Math.max(...this._lines.map(line=>this._textContext.measureText(line).width));const match=this._textFont.match(/(\d+)px/);if(match){this._fontSize=parseInt(match[1],10);}
else{this._fontSize=18;this._textFont="18px Arial";}
this._height=this._lines.length*(this._fontSize+this._lineSpacing);this._paddingx=5;this._paddingtop=3;this._canvasWidth=Math.ceil(this._width+this._paddingx*2);this._canvasHeight=Math.ceil(this._height+this._paddingtop);this._textCanvas.width=this._canvasWidth;this._textCanvas.height=this._canvasHeight;this._textContext.font=this._textFont;this._textContext.textBaseline='top';}
updateText(newText){this._lines=newText.split('\n');this._textContext.fillStyle='rgba(1, 1, 1, 0.5)';this._textContext.clearRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillStyle='white';this._lines.forEach((line,idx)=>{const x=this._paddingx;const y=this._paddingtop+idx*(this._fontSize+this._lineSpacing);this._textContext.fillText(line,x,y);});}}
class PGA3D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1]-a[2]*b[2]-a[3]*b[3]-a[7]*b[7]+a[11]*b[11]+a[12]*b[12]+a[13]*b[13],a[0]*b[1]+a[1]*b[0]-a[2]*b[3]+a[3]*b[2]+a[7]*b[13]+a[11]*b[12]-a[12]*b[11]+a[13]*b[7],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1]-a[7]*b[12]+a[11]*b[13]-a[12]*b[7]-a[13]*b[11],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]+a[7]*b[11]+a[11]*b[7]+a[12]*b[13]-a[13]*b[12],a[0]*b[4]+a[1]*b[5]+a[2]*b[6]-a[3]*b[15]+a[4]*b[0]-a[5]*b[1]-a[6]*b[2]+a[7]*b[10]+a[8]*b[12]+a[9]*b[13]-a[10]*b[7]-a[11]*b[14]+a[12]*b[8]+a[13]*b[9]+a[14]*b[11]-a[15]*b[3],a[0]*b[5]-a[1]*b[4]+a[2]*b[15]+a[3]*b[6]+a[4]*b[1]+a[5]*b[0]-a[6]*b[3]-a[7]*b[9]-a[8]*b[11]+a[9]*b[7]+a[10]*b[12]-a[11]*b[8]-a[12]*b[14]+a[13]*b[10]+a[14]*b[12]+a[15]*b[2],a[0]*b[6]-a[1]*b[15]-a[2]*b[4]-a[3]*b[5]+a[4]*b[2]+a[5]*b[3]+a[6]*b[0]+a[7]*b[8]-a[8]*b[7]-a[9]*b[11]-a[10]*b[12]-a[11]*b[9]-a[12]*b[10]-a[13]*b[14]+a[14]*b[13]-a[15]*b[1],a[0]*b[7]+a[1]*b[13]-a[2]*b[12]+a[3]*b[11]+a[7]*b[0]+a[11]*b[3]-a[12]*b[2]+a[13]*b[1],a[0]*b[8]+a[1]*b[14]-a[2]*b[10]+a[3]*b[9]+a[4]*b[12]-a[5]*b[11]+a[6]*b[7]-a[7]*b[6]+a[8]*b[0]-a[9]*b[3]+a[10]*b[2]-a[11]*b[5]+a[12]*b[4]-a[13]*b[15]+a[14]*b[1]+a[15]*b[13],a[0]*b[9]+a[1]*b[10]+a[2]*b[14]-a[3]*b[8]+a[4]*b[13]-a[5]*b[7]-a[6]*b[11]+a[7]*b[5]+a[8]*b[3]+a[9]*b[0]-a[10]*b[1]-a[11]*b[6]+a[12]*b[15]+a[13]*b[4]+a[14]*b[2]-a[15]*b[12],a[0]*b[10]-a[1]*b[9]+a[2]*b[8]+a[3]*b[14]+a[4]*b[7]+a[5]*b[13]-a[6]*b[12]-a[7]*b[4]-a[8]*b[2]+a[9]*b[1]+a[10]*b[0]-a[11]*b[15]-a[12]*b[6]+a[13]*b[5]+a[14]*b[3]+a[15]*b[11],a[0]*b[11]+a[1]*b[12]+a[2]*b[13]-a[3]*b[7]-a[7]*b[3]+a[11]*b[0]-a[12]*b[1]-a[13]*b[2],a[0]*b[12]-a[1]*b[11]+a[2]*b[7]+a[3]*b[13]+a[7]*b[2]+a[11]*b[1]+a[12]*b[0]-a[13]*b[3],a[0]*b[13]-a[1]*b[7]-a[2]*b[11]-a[3]*b[12]-a[7]*b[1]+a[11]*b[2]+a[12]*b[3]+a[13]*b[0],a[0]*b[14]-a[1]*b[8]-a[2]*b[9]-a[3]*b[10]+a[4]*b[11]+a[5]*b[12]+a[6]*b[13]+a[7]*b[15]-a[8]*b[1]-a[9]*b[2]-a[10]*b[3]-a[11]*b[4]-a[12]*b[5]-a[13]*b[6]+a[14]*b[0]-a[15]*b[7],a[0]*b[15]+a[1]*b[6]-a[2]*b[5]+a[3]*b[4]+a[4]*b[3]-a[5]*b[2]+a[6]*b[1]-a[7]*b[14]+a[8]*b[13]-a[9]*b[12]+a[10]*b[11]-a[11]*b[10]+a[12]*b[9]-a[13]*b[8]+a[14]*b[7]+a[15]*b[0],];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3],-a[4],-a[5],-a[6],-a[7],-a[8],-a[9],-a[10],a[11],a[12],a[13],a[14],a[15]];}
static applyMotor(p,m){return PGA3D.geometricProduct(m,PGA3D.geometricProduct(p,PGA3D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m.map(val=>val*val).reduce((s,val)=>s+val,0));}
static createTranslator(dx,dy,dz){return[1,0,0,0,-dx/2,-dy/2,-dz/2,0,0,0,0,0,0,0,0,0];}
static extractTranslator(m){return[1,0,0,0,m[4],m[5],m[6],0,0,0,0,0,0,0,0,0];}
static createRotor(angle,dx=1,dy=0,dz=0,sx=0,sy=0,sz=0){let c=Math.cos(angle/2);let s=Math.sin(angle/2);let L=PGA3D.createLine(sx,sy,sz,dx,dy,dz);return[c,s*L[1],s*L[2],s*L[3],s*L[4],s*L[5],s*L[6],0,0,0,0,0,0,0,0,0];}
static extractRotor(m){return[m[0],m[1],m[2],m[3],0,0,0,0,0,0,0,0,0,0,0,0];}
static createDir(dx,dy,dz){return[0,dz,-dy,dx,0,0,0,0,0,0,0,0,0,0,0,0];}
static createLine(sx,sy,sz,dx,dy,dz){let n=PGA3D.createDir(dx,dy,dz);let dir=PGA3D.normalizeMotor(n);return[0,dir[1],dir[2],dir[3],-(-dir[2]*sz-dir[1]*sy),-(dir[1]*sx-dir[3]*sz),-(dir[3]*sy+dir[2]*sx),0,0,0,0,0,0,0,0,0];}
static createPoint(x,y,z){return[0,0,0,0,0,0,0,1,-z,y,-x,0,0,0,0,0];}
static extractPoint(p){return[-p[10]/p[7],p[9]/p[7],-p[8]/p[7]];}
static createPlane(nx,ny,nz,d){return[0,0,0,0,0,0,0,0,0,0,0,nx,ny,nz,-d,0];}
static createPlaneFromPoints(p1,p2,p3){let nx=(p2[1]*p3[2]-p3[1]*p2[2])-(p1[1]*p3[2]-p3[1]*p1[2])+(p1[1]*p2[2]-p2[1]*p1[2]);let ny=(p2[0]*p3[2]-p3[0]*p2[2])-(p1[0]*p3[2]-p3[0]*p1[2])+(p1[0]*p2[2]-p2[0]*p1[2]);let nz=(p2[0]*p3[1]-p3[0]*p2[1])-(p1[0]*p3[1]-p3[0]*p1[1])+(p1[0]*p2[1]-p2[0]*p1[1]);let d=(p1[0]*(p2[1]*p3[2]-p3[1]*p2[2])-p2[0]*(p1[1]*p3[2]-p3[1]*p1[2])+p3[0]*(p1[1]*p2[2]-p2[1]*p1[2]));return PGA3D.createPlane(nx,-ny,nz,d);}
static linePlaneIntersection(L,P){let new_p=PGA3D.geometricProduct(L,P);let isParallel=(Math.abs(new_p[7])<=0.00000001);let inPlane=isParallel&&(Math.abs(new_p[8])<=0.00000001)&&(Math.abs(new_p[9])<=0.00000001)&&(Math.abs(new_p[10])<=0.00000001);return[PGA3D.extractPoint(new_p),!isParallel,inPlane];}
static normalizeMotor(m){let mnorm=PGA3D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];}
return m.map(val=>val/mnorm);}
static applyMotorToPoint(p,m){let new_p=PGA3D.applyMotor(PGA3D.createPoint(p[0],p[1],p[2]),m);return PGA3D.extractPoint(new_p);};static applyMotorToDir(d,m){let r=PGA3D.extractRotor(m);let new_d=PGA3D.applyMotor(PGA3D.createPoint(d[0],d[1],d[2]),r);return PGA3D.extractPoint(new_d);}
static isInside(v0,v1,v2,p){let pga0=PGA3D.createPoint(v0[0],v0[1],v0[2]);let pga1=PGA3D.createPoint(v1[0],v1[1],v1[2]);let pga2=PGA3D.createPoint(v2[0],v2[1],v2[2]);let pgap=PGA3D.createPoint(p[0],p[1],p[2]);let plane012=PGA3D.createPlaneFromPoints(v0,v1,v2);let planep12=PGA3D.createPlaneFromPoints(p,v1,v2);let plane0p2=PGA3D.createPlaneFromPoints(v0,p,v2);let plane01p=PGA3D.createPlaneFromPoints(v0,v1,p);let area012=plane012[11]*plane012[11]+plane012[12]*plane012[12]+plane012[13]*plane012[13]+plane012[14]*plane012[14];let areap12=plane012[11]*planep12[11]+plane012[12]*planep12[12]+plane012[13]*planep12[13]+plane012[14]*planep12[14];let area0p2=plane012[11]*plane0p2[11]+plane012[12]*plane0p2[12]+plane012[13]*plane0p2[13]+plane012[14]*plane0p2[14];let area01p=plane012[11]*plane01p[11]+plane012[12]*plane01p[12]+plane012[13]*plane01p[13]+plane012[14]*plane01p[14];let lambda1=areap12/area012;let lambda2=area0p2/area012;let lambda3=area01p/area012;return lambda1>=0&&lambda1<=1&&lambda2>=0&&lambda2<=1&&lambda3>=0&&lambda3<=1;}}
class Camera{constructor(width,height){this._pose=new Float32Array(Array(16).fill(0));this._pose[0]=1;this._focal=new Float32Array(Array(2).fill(1));this._resolutions=new Float32Array([width,height]);}
resetPose(){this._pose[0]=1;for(let i=1;i<16;++i)this._pose[i]=0;this._focal[0]=1;this._focal[1]=1;}
updatePose(newpose){for(let i=0;i<16;++i)this._pose[i]=newpose[i];}
updateSize(width,height){this._resolutions[0]=width;this._resolutions[1]=height;}
moveX(d){this.updatePose(newpose);}
moveY(d){this.updatePose(newpose);}
moveZ(d){this.updatePose(newpose);}
rotateX(d){this.updatePose(newpose);}
rotateY(d){this.updatePose(newpose);}
rotateZ(d){this.updatePose(newpose);}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){throw new Error("Method 'createShaders()' must be implemented.");}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}}
class MeshIO{constructor(){if(this.constructor==MeshIO){throw new Error("Abstract classes can't be instantiated.");}}
static async read(filename){throw new Error("Method 'read(filename)' must be implemented.");}
static async write(mesh,filename,isASCII=false){throw new Error("Method 'write(filename)' muste be implemented.");}}
class PlyIO extends MeshIO{constructor(){}
static readBinary(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.responseType='arraybuffer';xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.response);}
else{reject(new Error('Error loading PLY file: '+xhttp.status));}}
xhttp.onerror=function(){reject(new Error('Network error loading PLY file'));}
xhttp.send();});}
static readHeader(text){const lines=text.split('\n');let offset=0;let vertexCount=0;let faceCount=0;let vertexProperties=[];let faceProperties=[];let reading='format';let format='unknown';offset+=lines[0].length+1;const line=lines[0].trim();if(line!=='ply'){throw new Error('Input is not a ply file: '+filename);}
for(let i=1;i<lines.length;++i){offset+=lines[i].length+1;const line=lines[i].trim();if(line==='end_header'){reading='data';break;}
if(line.startsWith('format')){format=line.split(' ')[1];}
if(line.startsWith('element vertex')){vertexCount=parseInt(line.split(' ')[2]);reading='vertex';}
else if(line.startsWith('element face')){faceCount=parseInt(line.split(' ')[2]);reading='face';}
else if(line.startsWith('property')){if(reading==='vertex'){vertexProperties.push(line.split(' ').slice(1).join(' '));}
else if(reading==='face'){faceProperties.push(line.split(' ').slice(1).join(' '));}}}
return[offset,vertexCount,faceCount,vertexProperties,faceProperties,format];}
static readASCIIPly(text,vCnt,fCnt){const vertices=[];const lines=text.split('\n');for(let i=0;i<vCnt;++i){const line=lines[i].trim();vertices.push(line.split(' ').map(parseFloat));}
const faces=[];for(let i=vCnt;i<vCnt+fCnt;++i){const line=lines[i].trim();let face=line.split(' ').slice(1);for(let i=0;i<face.length-2;++i){faces.push([parseInt(face[0]),parseInt(face[i+1]),parseInt(face[i+2])]);}}
return[vertices,faces];}
static readBytes(view,offset,isLittle,type){switch(type){case'char':return[view.getInt8(offset,1)];break;case'uchar':return[view.getUint8(offset,1)];break;case'short':return[view.getInt16(offset,isLittle),2];break;case'ushort':return[view.getUint16(offset,isLittle),2];break;case'int':return[view.getInt32(offset,isLittle),4];break;case'uint':return[view.getUint32(offset,isLittle),4];break;case'float':return[view.getFloat32(offset,isLittle),4];break;case'double':return[view.getFloat64(offset,isLittle),8];break;}}
static readBinaryPly(view,offset,vCnt,fCnt,vProp,fProp,fmt){let isLittle=fmt.includes('little');const vertices=[];for(let i=0;i<vCnt;++i){const vertex=[];for(let j=0;j<vProp.length;++j){const[type,_]=vProp[j].split(' ');const[value,delta]=PlyIO.readBytes(view,offset,isLittle,type);vertex.push(value);offset+=delta;}
vertices.push(vertex);}
const[fType,type1,type2,_]=fProp[0].split(' ');const faces=[];for(let i=0;i<fCnt;++i){const[numIndices,delta]=PlyIO.readBytes(view,offset,isLittle,type1);offset+=delta;const face=[];for(let j=0;j<numIndices;++j){const[value,delta]=PlyIO.readBytes(view,offset,isLittle,type2);face.push(value);offset+=delta;}
for(let i=0;i<face.length-2;++i){faces.push([face[0],face[i+1],face[i+2]]);}}
return[vertices,faces];}
static async read(filename){let binarydata=await PlyIO.readBinary(filename);let text=new TextDecoder().decode(binarydata);const[offset,vCnt,fCnt,vProp,fProp,fmt]=PlyIO.readHeader(text);if(fmt==='ascii'){const[v,t]=PlyIO.readASCIIPly(text.substring(offset),vCnt,fCnt,vProp,fProp);return[v,t,vProp];}
else{const[v,t]=PlyIO.readBinaryPly(new DataView(binarydata),offset,vCnt,fCnt,vProp,fProp,fmt);return[v,t,vProp];}}
static isLittleEndian(){const buffer=new ArrayBuffer(2);const view=new DataView(buffer);view.setInt16(0,256,true);return view.getInt8(0)===0;}
static async write(mesh,filename,isASCII=false){const isLittle=PlyIO.isLittleEndian();let plyData='ply\nformat '+(isASCII?'ascii':(isLittle?'binary_little_endian':'binary_big_endian'))+' 1.0\n';plyData+=`element vertex ${mesh.numV}\n`;for(let i=0;i<mesh.vProp.length;++i){plyData+=`property ${mesh.vProp[i]}\n`;}
plyData+=`element face ${mesh.numT}\n`;plyData+=`property list int int vertex_indices\nend_header\n`;if(isASCII){for(let i=0;i<mesh.numV;++i){let line='';for(let j=0;j<mesh.vProp.length;++j){line+=`${mesh.vertices[i * mesh.vProp.length + j]} `;}
plyData+=line.trim()+'\n';}
for(let i=0;i<mesh.numT;++i){plyData+=`3 ${mesh.triangles[3 * i]} ${mesh.triangles[3 * i + 1]} ${mesh.triangles[3 * i + 2]}\n`;}
const blob=new Blob([plyData],{type:'text/plain'});const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='download.ply';a.click();URL.revokeObjectURL(a.href);}
else{const vertexData=new Uint8Array(mesh.vertices.length*4);mesh.vertices.forEach((value,index)=>{const view=new Float32Array([value]);vertexData.set(new Uint8Array(view.buffer),index*4);});const faceData=new Uint8Array(mesh.numT*4*4);for(let i=0;i<mesh.numT;++i){const view=new Int32Array([3,mesh.triangles[3*i],mesh.triangles[3*i+1],mesh.triangles[3*i+2]]);faceData.set(new Uint8Array(view.buffer),i*4*4);}
const blob=new Blob([new TextEncoder().encode(plyData),vertexData,faceData],{type:'application/octet-stream'});const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='download.ply';a.click();URL.revokeObjectURL(a.href);}}}
class TriangleMesh{constructor(filename){this._filename=filename;this._laplacianScheme='uniform';}
buildAdjacency(){this._adjList=new Map();for(let i=0;i<this._triangles.length;i++){const i0=this._triangles[i][0];const i1=this._triangles[i][1];const i2=this._triangles[i][2];for(const[a,b]of[[i0,i1],[i1,i2],[i2,i0]]){if(!this._adjList.has(a))this._adjList.set(a,new Set());this._adjList.get(a).add(b);}}
for(let[v,neighbors]of this._adjList.entries()){this._adjList.set(v,Array.from(neighbors));}}
computeLaplacianCoordinates(){this._laplacian=new Array(this._numV).fill(null);for(let i=0;i<this._numV;++i){const v=this._vertices[i].slice(0,3);const neighbors=this._adjList.get(i);const n=neighbors.length;let avg=[0,0,0];for(const j of neighbors){const nv=this._vertices[j].slice(0,3);avg[0]+=nv[0];avg[1]+=nv[1];avg[2]+=nv[2];}
avg=avg.map(val=>val/n);this._laplacian[i]=[v[0]-avg[0],v[1]-avg[1],v[2]-avg[2]];}}
computeLaplacianCoordinatesEdge(){this._laplacian=new Array(this._numV).fill(null);for(let i=0;i<this._numV;++i){const v=this._vertices[i].slice(0,3);const neighbors=this._adjList.get(i);const n=neighbors.length;let sumWeight=0;let weightedSum=[0,0,0];for(const j of neighbors){const vj=this._vertices[j].slice(0,3);const dist=Math.hypot(vj[0]-vi[0],vj[1]-vi[1],vj[2]-vi[2]);const w=dist>0?1.0/dist:0;sumWeight+=w;for(let k=0;k<3;++k){weightedSum[k]+=w*vj[k];}}
for(let k=0;k<3;++k){weightedSum[k]/=sumWeight;}
this._laplacian[i]=[vi[0]-weightedSum[0],vi[1]-weightedSum[1],vi[2]-weightedSum[2]];}}
computeLaplacianCoordinatesEdgeLengthWeighted(){this._laplacian=new Array(this._numV).fill(null);for(let i=0;i<this._numV;++i){const vi=this._vertices[i].slice(0,3);const neighbors=this._adjList.get(i);let sumWeight=0;let weightedSum=[0,0,0];for(const j of neighbors){const vj=this._vertices[j].slice(0,3);const dist=Math.hypot(vj[0]-vi[0],vj[1]-vi[1],vj[2]-vi[2]);const w=dist>0?1.0/dist:0;sumWeight+=w;for(let k=0;k<3;++k){weightedSum[k]+=w*vj[k];}}
for(let k=0;k<3;++k){weightedSum[k]/=sumWeight;}
this._laplacian[i]=[vi[0]-weightedSum[0],vi[1]-weightedSum[1],vi[2]-weightedSum[2]];}}
computeLaplacianCoordinatesAreaWeighted(){this._laplacian=new Array(this._numV).fill(null);const vertexFaceMap=new Map();for(let i=0;i<this._numT;++i){for(let v of this._triangles[i]){if(!vertexFaceMap.has(v))vertexFaceMap.set(v,[]);vertexFaceMap.get(v).push(i);}}
for(let i=0;i<this._numV;++i){const vi=this._vertices[i].slice(0,3);const faces=vertexFaceMap.get(i);let sumWeight=0;let weightedSum=[0,0,0];for(const f of faces){const tri=this._triangles[f];for(let j of tri){if(j!==i){const vj=this._vertices[j].slice(0,3);const w=this._faceArea[f];sumWeight+=w;for(let k=0;k<3;++k){weightedSum[k]+=w*vj[k];}}}}
for(let k=0;k<3;++k){weightedSum[k]/=sumWeight;}
this._laplacian[i]=[vi[0]-weightedSum[0],vi[1]-weightedSum[1],vi[2]-weightedSum[2]];}}
computeLaplacianCoordinatesByScheme(){if(this._laplacianScheme==='uniform'){this.computeLaplacianCoordinates();}else if(this._laplacianScheme==='edge'){this.computeLaplacianCoordinatesEdgeLengthWeighted();}else if(this._laplacianScheme==='area'){this.computeLaplacianCoordinatesAreaWeighted();}else if(this._laplacianScheme==='none'){this._laplacian=null;}else{throw new Error("Unknown Laplacian scheme: "+this._laplacianScheme);}}
interpolateVerticesLaplacian(otherMesh,t){const interpolatedVertices=new Array(this._numV);if(!this._laplacian||!otherMesh._laplacian){throw new Error("Laplacians not computed. Call computeLaplacianCoordinates() first.");}
const interpolatedLaplacians=new Array(this._numV);for(let i=0;i<this._numV;++i){const d0=this._laplacian[i];const d1=otherMesh._laplacian[i];interpolatedLaplacians[i]=[(1-t)*d0[0]+t*d1[0],(1-t)*d0[1]+t*d1[1],(1-t)*d0[2]+t*d1[2]];}
for(let i=0;i<this._numV;++i){const v0=this._vertices[i].slice(0,3);const v1=otherMesh._vertices[i].slice(0,3);interpolatedVertices[i]=[(1-t)*v0[0]+t*v1[0],(1-t)*v0[1]+t*v1[1],(1-t)*v0[2]+t*v1[2]];}
for(let iter=0;iter<10;++iter){const newVertices=new Array(this._numV);for(let i=0;i<this._numV;++i){const neighbors=this._adjList.get(i);const n=neighbors.length;let avg=[0,0,0];for(const j of neighbors){const vj=interpolatedVertices[j];avg[0]+=vj[0];avg[1]+=vj[1];avg[2]+=vj[2];}
avg=avg.map(val=>val/n);const d=interpolatedLaplacians[i];newVertices[i]=[d[0]+avg[0],d[1]+avg[1],d[2]+avg[2]];}
for(let i=0;i<this._numV;++i){interpolatedVertices[i]=newVertices[i];}}
return interpolatedVertices;}
centerOfMass(){let C=[0.0,0.0,0.0];for(let i=0;i<this._numV;++i){for(let j=0;j<3;++j){C[j]+=this._vertices[i][j];}}
for(let i=0;i<3;++i){C[i]/=this._numV;}
return C;}
surfaceArea(){const l=(a,b)=>Math.sqrt(Math.pow(b[0]-a[0],2)+Math.pow(b[1]-a[1],2)+Math.pow(b[2]-a[2],2));const area=(e0,e1,e2,s)=>Math.sqrt(s*(s-e0)*(s-e1)*(s-e2));let A=0;this._faceArea=new Array(this._numT);for(let i=0;i<this._numT;++i){const v0=this._vertices[this._triangles[i][0]];const v1=this._vertices[this._triangles[i][1]];const v2=this._vertices[this._triangles[i][2]];const e01=l(v0,v1);const e12=l(v1,v2);const e20=l(v2,v0);const s=(e01+e12+e20)/2;this._faceArea[i]=area(e01,e12,e20,s);A+=this._faceArea[i];}
return A;}
normalizeMesh(){this._center=this.centerOfMass();for(let i=0;i<this._numV;++i){for(let j=0;j<3;++j){this._vertices[i][j]-=this._center[j];}}
this._area=this.surfaceArea();const targetArea=1;this._scaleFactor=Math.sqrt(1/this._area*targetArea);for(let i=0;i<this._numV;++i){for(let j=0;j<3;++j){this._vertices[i][j]*=this._scaleFactor;}}
if(Math.abs(this.surfaceArea()-targetArea)>0.0001){console.log("Something is wrong! The surface area is not as expected!");}}
computeNormal(){this._faceNormal=new Array(this._numT);this._normal=Array.from({length:this._numV},(_)=>new Array(3).fill(0));const normal=(p0,p1,p2)=>{let v1=[p1[0]-p0[0],p1[1]-p0[1],p1[2]-p0[2]];let v2=[p2[0]-p0[0],p2[1]-p0[1],p2[2]-p0[2]];let normal=[v1[1]*v2[2]-v1[2]*v2[1],v1[2]*v2[0]-v1[0]*v2[2],v1[0]*v2[1]-v1[1]*v2[0]];let length=Math.sqrt(normal[0]**2+normal[1]**2+normal[2]**2);normal=normal.map(n=>n/length);return normal;};for(let i=0;i<this._numT;++i){if(this._faceArea[i]>0){this._faceNormal[i]=normal(this._vertices[this._triangles[i][0]],this._vertices[this._triangles[i][1]],this._vertices[this._triangles[i][2]])
for(let j=0;j<3;++j){for(let k=0;k<3;++k){this._normal[this._triangles[i][j]][k]+=this._faceNormal[i][k]*this._faceArea[i]/3;}}}
else{this._faceNormal[i]=new Array(3);}}}
appendNormalToVertices(){this._vProp.push('normal x','normal y','normal z');for(let i=0;i<this._numV;++i){let length=Math.sqrt(this._normal[i][0]**2+this._normal[i][1]**2+this._normal[i][2]**2);this._normal[i]=this._normal[i].map(n=>n/length);this._vertices[i].push(this._normal[i][0],this._normal[i][1],this._normal[i][2]);}}
async init(){let result=await PlyIO.read(this._filename);if(!result||result.length!==3){throw new Error(`Failed to load mesh from ${this._filename}`);}
let[vertices,triangles,vProp]=result;if(!vertices||!triangles||!vProp){throw new Error(`Missing vertices/triangles/vProp from ${this._filename}`);}
if(!Array.isArray(triangles[0])){const grouped=[];for(let i=0;i<triangles.length;i+=3){grouped.push([triangles[i],triangles[i+1],triangles[i+2]]);}
triangles=grouped;console.log("Converted flat triangle list to nested format:",triangles);}
console.log("BB");this._numV=vertices.length;this._numT=triangles.length;this._vProp=vProp;this._vertices=vertices;this._triangles=triangles;this.buildAdjacency();this.normalizeMesh();this.computeLaplacianCoordinatesByScheme();if(this._vProp.length==3){this.computeNormal();this.appendNormalToVertices();}}}
class CameraTriangleMeshLinearInterpolationObject extends SceneObject{constructor(device,canvasFormat,srcfile,tgtfile,camera){super(device,canvasFormat);this._srcmesh=new TriangleMesh(srcfile);this._tgtmesh=new TriangleMesh(tgtfile);this._camera=camera;this._t=new Float32Array([0.,0.,0.]);this._delta=0.01;this._interpolationMode='none';this._useLaplacian=true;}
async createGeometry(){await this._srcmesh.init();await this._tgtmesh.init();this._numV=this._srcmesh._numV;this._numT=this._srcmesh._numT;this._vProp=this._srcmesh._vProp;this._vertices=new Array(this._numV);for(let i=0;i<this._numV;++i){this._vertices[i]=[...this._srcmesh._vertices[i],...this._tgtmesh._vertices[i]];}
this._vertices=this._vertices.flat();this._triangles=this._srcmesh._triangles.flat();console.log("C");console.log(this._vertices.length);this._vertexBuffer=this._device.createBuffer({label:"Vertices Normals and More",size:this._vertices.length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:true});new Float32Array(this._vertexBuffer.getMappedRange()).set(this._vertices);this._vertexBuffer.unmap();console.log(this._vProp.length);this._vertexBufferLayout={arrayStride:this._vProp.length*Float32Array.BYTES_PER_ELEMENT*2,attributes:[{format:"float32x3",offset:0,shaderLocation:0,},{format:"float32x3",offset:3*Float32Array.BYTES_PER_ELEMENT,shaderLocation:1,},{format:"float32x3",offset:6*Float32Array.BYTES_PER_ELEMENT,shaderLocation:2,},{format:"float32x3",offset:9*Float32Array.BYTES_PER_ELEMENT,shaderLocation:3,}],};console.log(this._triangles.length);this._indexBuffer=this._device.createBuffer({label:"Indices",size:this._triangles.length*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:true});new Uint32Array(this._indexBuffer.getMappedRange()).set(this._triangles);this._indexBuffer.unmap();const cameraUniformSize=96;this._cameraBuffer=this._device.createBuffer({label:"Camera "+this.getName(),size:cameraUniformSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._laplacianData=new Uint32Array([0]);this._laplacianBuffer=this._device.createBuffer({label:"Laplacian buffer",size:this._laplacianData.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._laplacianBuffer,0,this._laplacianData);this._renderModeData=new Uint32Array([0]);this._renderModeBuffer=this._device.createBuffer({label:"render mode buffer",size:this._renderModeData.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._renderModeBuffer,0,this._renderModeData);this.setRenderMode(1);this._device.queue.writeBuffer(this._cameraBuffer,0,this._camera._pose);this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength,this._camera._focal);this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength+this._camera._focal.byteLength,this._camera._resolutions);this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength+this._camera._focal.byteLength+this._camera._resolutions.byteLength,this._t);}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraBuffer,0,this._camera._pose);}
updateCameraFocal(){this._device.queue.writeBuffer(this._cameraBuffer,this._camera._pose.byteLength,this._camera._focal);}
updateGeometry(){this._t[0]=this._t[0]+this._delta;if(this._t[0]>=1.||this._t[0]<=0.){this._delta*=-1;}
const offset=this._camera._pose.byteLength+this._camera._focal.byteLength+this._camera._resolutions.byteLength;this._device.queue.writeBuffer(this._cameraBuffer,offset,this._t);this._laplacianData[0]=this._interpolationMode==='none'?0:1;this._device.queue.writeBuffer(this._laplacianBuffer,0,this._laplacianData);if(this._interpolationMode!=='none'){const t=this._t[0];const interpVerts=this._srcmesh.interpolateVerticesLaplacian(this._tgtmesh,t);const updatedVerts=[];for(let i=0;i<this._numV;++i){const normal=this._srcmesh._normal[i];updatedVerts.push(...interpVerts[i],...normal,...interpVerts[i],...normal);}
const flat=new Float32Array(updatedVerts.flat());this._device.queue.writeBuffer(this._vertexBuffer,0,flat);}}
setRenderMode(modeIndex){this._renderModeData[0]=modeIndex;this._device.queue.writeBuffer(this._renderModeBuffer,0,this._renderModeData);console.log(this._renderModeData[0]);}
async createShaders(){let shaderCode=await this.loadShader("/shaders/optimized_camerameshlinearinterpolation.wgsl");this._meshShaderModule=this._device.createShaderModule({label:"Mesh Shader",code:shaderCode,});}
async createRenderPipeline(){this._meshRenderPipeline=this._device.createRenderPipeline({label:"Mesh Render Pipeline",layout:"auto",vertex:{module:this._meshShaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._meshShaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},depthStencil:{format:"depth24plus",depthWriteEnabled:true,depthCompare:"less"},primitive:{topology:"triangle-list",cullMode:"none"}});this._bindGroup=this._device.createBindGroup({label:"Interpolation Bind Group ",layout:this._meshRenderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraBuffer}},{binding:1,resource:{buffer:this._laplacianBuffer}},{binding:2,resource:{buffer:this._renderModeBuffer}}]});}
render(pass){pass.setPipeline(this._meshRenderPipeline);pass.setBindGroup(0,this._bindGroup);pass.setVertexBuffer(0,this._vertexBuffer);pass.setIndexBuffer(this._indexBuffer,'uint32');pass.drawIndexed(this._triangles.length,1,0,0,0);}
async createComputePipeline(){}
compute(pass){}}
function createWeightingButtons(mesh){const container=document.createElement('div');container.style.position='absolute';container.style.top='10px';container.style.right='10px';container.style.backgroundColor='rgba(255, 255, 255, 0.9)';container.style.padding='10px';container.style.borderRadius='8px';container.style.boxShadow='0 2px 10px rgba(0,0,0,0.2)';container.style.zIndex='1000';container.style.fontFamily='sans-serif';container.style.display='flex';container.style.flexDirection='column';container.style.alignItems='flex-end';const label=document.createElement('span');label.id='currentScheme';label.textContent='Current scheme: None';label.style.marginBottom='8px';label.style.fontSize='14px';label.style.fontWeight='bold';container.appendChild(label);const schemes=['none','uniform','edge','area'];for(let scheme of schemes){const button=document.createElement('button');button.textContent=scheme[0].toUpperCase()+scheme.slice(1);button.style.margin='2px 0';button.style.padding='4px 8px';button.style.fontSize='13px';button.style.cursor='pointer';button.style.borderRadius='4px';button.style.border='1px solid #ccc';button.onclick=()=>{mesh._interpolationMode=scheme;if(scheme=='none'){console.log("Deault GPU-based interpolation");mesh._srcmesh._laplacianScheme=scheme;mesh._tgtmesh._laplacianScheme=scheme;mesh._srcmesh.computeLaplacianCoordinatesByScheme();mesh._tgtmesh.computeLaplacianCoordinatesByScheme();}else{mesh._srcmesh._laplacianScheme=scheme;mesh._tgtmesh._laplacianScheme=scheme;mesh._srcmesh.computeLaplacianCoordinatesByScheme();mesh._tgtmesh.computeLaplacianCoordinatesByScheme();console.log(`Switched to ${scheme} Laplacian interpolation`);}
label.textContent=`Current scheme: ${scheme[0].toUpperCase() + scheme.slice(1)}`;};container.appendChild(button);}
document.body.appendChild(container);}
function createRenderModeButtons(mesh){const container=document.createElement('div');container.style.position='absolute';container.style.top='160px';container.style.right='10px';container.style.backgroundColor='rgba(255, 255, 255, 0.9)';container.style.padding='10px';container.style.borderRadius='8px';container.style.boxShadow='0 2px 10px rgba(0,0,0,0.2)';container.style.zIndex='1000';container.style.fontFamily='sans-serif';container.style.display='flex';container.style.flexDirection='column';container.style.alignItems='flex-end';const label=document.createElement('span');label.id='currentRenderMode';label.textContent='Render mode: MIP';label.style.marginBottom='8px';label.style.fontSize='14px';label.style.fontWeight='bold';container.appendChild(label);const modes=[{name:'MIP',value:0},{name:'DRR',value:1},{name:'Depth Encoding',value:2},];for(let mode of modes){const button=document.createElement('button');button.textContent=mode.name;button.style.margin='2px 0';button.style.padding='4px 8px';button.style.fontSize='13px';button.style.cursor='pointer';button.style.borderRadius='4px';button.style.border='1px solid #ccc';button.onclick=()=>{if(mesh.setRenderMode){mesh.setRenderMode(mode.value);label.textContent=`Render mode: ${mode.name}`;console.log(`Switched to ${mode.name} rendering`);}};container.appendChild(button);}
document.body.appendChild(container);}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const renderer=new Renderer(canvasTag);await renderer.init();var camera=new Camera();camera._pose[0]=0.18809913098812103;camera._pose[1]=-0.0767698660492897;camera._pose[2]=-0.0767698660492897;camera._pose[3]=0.18809913098812103;camera._pose[4]=-0.6141012907028198;camera._pose[5]=0.29343530535697937;camera._pose[6]=0.6404831409454346;camera._pose[15]=0.20977813005447388;camera._focal[0]=4;camera._focal[1]=4;var mesh=new CameraTriangleMeshLinearInterpolationObject(renderer._device,renderer._canvasFormat,'/assets/TOSCA/cat0.ply','/assets/TOSCA/cat10.ply',camera);await renderer.appendSceneObject(mesh);createWeightingButtons(mesh);let fps='??';var fpsText=new StandardTextObject('fps: '+fps);var frameCnt=0;var tgtFPS=60;var secPerFrame=1./tgtFPS;var frameInterval=secPerFrame*1000;var lastCalled;let renderFrame=()=>{let elapsed=Date.now()-lastCalled;if(elapsed>frameInterval){++frameCnt;lastCalled=Date.now()-(elapsed%frameInterval);renderer.render();}
requestAnimationFrame(renderFrame);};lastCalled=Date.now();renderFrame();setInterval(()=>{fpsText.updateText('fps: '+frameCnt);frameCnt=0;},1000);return renderer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});